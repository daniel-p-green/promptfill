<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PromptFill Inline</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 12px;
        background: transparent;
        color: canvastext;
      }

      .card {
        border: 1px solid color-mix(in srgb, canvastext 16%, transparent);
        border-radius: 14px;
        background: color-mix(in srgb, canvas 92%, transparent);
        padding: 12px;
      }

      .header {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: flex-start;
      }

      .title {
        margin: 0;
        font-size: 14px;
        line-height: 1.2;
        font-weight: 600;
      }

      .subtitle {
        margin: 4px 0 0;
        font-size: 12px;
        line-height: 1.4;
        color: color-mix(in srgb, canvastext 65%, transparent);
      }

      .section {
        margin-top: 10px;
      }

      textarea,
      input,
      select {
        width: 100%;
        border: 1px solid color-mix(in srgb, canvastext 16%, transparent);
        border-radius: 10px;
        background: color-mix(in srgb, canvas 98%, transparent);
        color: inherit;
        font: inherit;
        padding: 8px 10px;
      }

      textarea {
        min-height: 92px;
        resize: vertical;
      }

      .fields {
        display: grid;
        gap: 8px;
      }

      .field {
        display: grid;
        gap: 4px;
      }

      .field-label {
        font-size: 11px;
        font-weight: 600;
        color: color-mix(in srgb, canvastext 72%, transparent);
      }

      .actions {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 8px;
      }

      button {
        border-radius: 999px;
        border: 1px solid color-mix(in srgb, canvastext 20%, transparent);
        font: inherit;
        font-size: 12px;
        font-weight: 600;
        padding: 6px 12px;
        cursor: pointer;
        background: color-mix(in srgb, canvas 94%, transparent);
        color: inherit;
      }

      button.primary {
        border-color: color-mix(in srgb, #10a37f 55%, transparent);
        background: #10a37f;
        color: white;
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .status {
        margin-top: 8px;
        font-size: 11px;
        color: color-mix(in srgb, canvastext 66%, transparent);
      }

      .rendered {
        margin-top: 10px;
        border: 1px solid color-mix(in srgb, canvastext 14%, transparent);
        border-radius: 10px;
        padding: 10px;
        white-space: pre-wrap;
        font-size: 12px;
        line-height: 1.5;
        max-height: 220px;
        overflow: auto;
      }

      .hint {
        font-size: 11px;
        color: color-mix(in srgb, canvastext 60%, transparent);
        margin-top: 6px;
      }
    </style>
  </head>
  <body>
    <article class="card" aria-live="polite">
      <div class="header">
        <div>
          <h1 class="title">PromptFill</h1>
          <p class="subtitle">Ask ChatGPT to "turn this prompt into a template" to begin.</p>
        </div>
      </div>

      <div class="section fields" id="fields"></div>

      <div class="actions">
        <button id="insert-button" type="button" disabled>Insert into chat</button>
        <button id="render-button" class="primary" type="button" disabled>Render prompt</button>
      </div>

      <div id="status" class="status">Waiting for extracted fields...</div>
      <pre id="rendered" class="rendered" hidden></pre>
      <div class="hint">This inline card keeps interactions lightweight and conversation-first.</div>
    </article>

    <script type="module">
      const fieldsContainer = document.getElementById("fields");
      const insertButton = document.getElementById("insert-button");
      const renderButton = document.getElementById("render-button");
      const statusEl = document.getElementById("status");
      const renderedEl = document.getElementById("rendered");

      let extraction = null;
      let fieldValues = {};

      let rpcId = 0;
      const pendingRequests = new Map();

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function toLabel(name) {
        return String(name)
          .split("_")
          .filter(Boolean)
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join(" ");
      }

      function renderFields() {
        fieldsContainer.innerHTML = "";

        if (!extraction || !Array.isArray(extraction.variables) || extraction.variables.length === 0) {
          renderButton.disabled = true;
          insertButton.disabled = true;
          return;
        }

        renderButton.disabled = false;

        for (const variable of extraction.variables) {
          const wrapper = document.createElement("label");
          wrapper.className = "field";

          const label = document.createElement("span");
          label.className = "field-label";
          label.textContent = `${toLabel(variable.name)}${variable.required ? " *" : ""}`;
          wrapper.appendChild(label);

          const current = fieldValues[variable.name] ?? variable.defaultValue ?? "";

          if (variable.type === "text") {
            const input = document.createElement("textarea");
            input.value = String(current);
            input.addEventListener("input", (event) => {
              fieldValues[variable.name] = event.currentTarget.value;
            });
            wrapper.appendChild(input);
          } else if (variable.type === "enum" && Array.isArray(variable.options) && variable.options.length > 0) {
            const select = document.createElement("select");
            for (const option of variable.options) {
              const optionEl = document.createElement("option");
              optionEl.value = option;
              optionEl.textContent = option;
              select.appendChild(optionEl);
            }
            select.value = String(current || variable.options[0]);
            fieldValues[variable.name] = select.value;
            select.addEventListener("change", (event) => {
              fieldValues[variable.name] = event.currentTarget.value;
            });
            wrapper.appendChild(select);
          } else {
            const input = document.createElement("input");
            input.type = variable.type === "number" ? "number" : "text";
            input.value = String(current);
            input.addEventListener("input", (event) => {
              fieldValues[variable.name] = event.currentTarget.value;
            });
            wrapper.appendChild(input);
          }

          fieldsContainer.appendChild(wrapper);
        }
      }

      function applyToolResult(toolResult) {
        const content = toolResult?.structuredContent;
        if (!content || typeof content !== "object") return;

        if (content.kind === "extraction") {
          extraction = content;
          fieldValues = {};

          for (const variable of content.variables ?? []) {
            const value = variable.defaultValue;
            if (value !== undefined && value !== null && value !== "") {
              fieldValues[variable.name] = value;
            }
          }

          renderFields();
          renderedEl.hidden = true;
          renderedEl.textContent = "";
          insertButton.disabled = true;
          setStatus(`Extracted ${content.summary?.variable_count ?? content.variables?.length ?? 0} fields.`);
          return;
        }

        if (content.kind === "render") {
          renderedEl.hidden = false;
          renderedEl.textContent = content.rendered_prompt ?? "";
          const hasMissingRequired =
            Array.isArray(content.missing_required) && content.missing_required.length > 0;
          insertButton.disabled = hasMissingRequired || !content.rendered_prompt;

          if (Array.isArray(content.missing_required) && content.missing_required.length > 0) {
            setStatus(`Missing required: ${content.missing_required.join(", ")}`);
          } else {
            setStatus("Rendered prompt ready.");
          }
          return;
        }

        if (content.kind === "list") {
          setStatus(`Saved templates: ${content.templates?.length ?? 0}`);
        }
      }

      function rpcNotify(method, params) {
        window.parent.postMessage({ jsonrpc: "2.0", method, params }, "*");
      }

      function rpcRequest(method, params) {
        return new Promise((resolve, reject) => {
          const id = ++rpcId;
          pendingRequests.set(id, { resolve, reject });
          window.parent.postMessage({ jsonrpc: "2.0", id, method, params }, "*");
        });
      }

      async function callTool(name, args) {
        const response = await rpcRequest("tools/call", {
          name,
          arguments: args,
        });

        applyToolResult(response);
        return response;
      }

      window.addEventListener(
        "message",
        (event) => {
          if (event.source !== window.parent) return;

          const message = event.data;
          if (!message || message.jsonrpc !== "2.0") return;

          if (typeof message.id === "number") {
            const request = pendingRequests.get(message.id);
            if (!request) return;
            pendingRequests.delete(message.id);

            if (message.error) {
              request.reject(message.error);
              return;
            }

            request.resolve(message.result);
            return;
          }

          if (message.method === "ui/notifications/tool-result") {
            applyToolResult(message.params);
          }
        },
        { passive: true }
      );

      async function initializeBridge() {
        await rpcRequest("ui/initialize", {
          appInfo: { name: "promptfill-inline", version: "0.1.0" },
          appCapabilities: {},
          protocolVersion: "2026-01-26",
        });
        rpcNotify("ui/notifications/initialized", {});
      }

      const bridgeReady = initializeBridge().catch((error) => {
        console.error("Bridge initialization failed:", error);
        setStatus("Unable to initialize widget bridge.");
      });

      renderButton.addEventListener("click", async () => {
        if (!extraction) return;

        renderButton.disabled = true;
        setStatus("Rendering prompt...");

        try {
          await bridgeReady;
          await callTool("render_prompt", {
            template: extraction.template,
            variables: extraction.variables,
            values: fieldValues,
          });
        } catch (error) {
          console.error("render_prompt failed", error);
          setStatus("Could not render prompt.");
        } finally {
          renderButton.disabled = false;
        }
      });

      insertButton.addEventListener("click", async () => {
        const renderedText = renderedEl.textContent?.trim();
        if (!renderedText) {
          setStatus("Render a prompt first.");
          return;
        }

        insertButton.disabled = true;
        setStatus("Inserting into chat...");

        try {
          await bridgeReady;
          const result = await rpcRequest("ui/message", {
            role: "user",
            content: [{ type: "text", text: renderedText }],
          });

          if (result?.isError) {
            setStatus("Could not insert into chat.");
            return;
          }

          setStatus("Inserted into chat.");
        } catch (error) {
          console.error("ui/message failed", error);
          setStatus("Could not insert into chat.");
        } finally {
          insertButton.disabled = false;
        }
      });
    </script>
  </body>
</html>
